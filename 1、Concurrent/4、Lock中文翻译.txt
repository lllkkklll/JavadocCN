---------------------------------- Lock类中文翻译

Lock实现比使用synchronized方法和语句, 提供了更广泛的锁操作。它们允许更灵活的结构, 可以有完全不同的属性, 并且支持多个相互关联的Condition对象。

锁是一个用于控制多个线程对共享资源的访问的工具。通常来说, 锁提供对共享资源的独立访问: 一次只能有一个线程可以获取到锁, 并且所有对共享资源的访问都需要优先获取到锁。然而, 有些锁会允许共享资源的并发访问, 列如读锁: ReadWriteLock。

synchronized方法或语句的使用, 提供了对每个对象关联的隐式monitor锁的访问。但是, 强制所有锁的获取和释放都应该以块状结构的方式出现: 当获取多个锁时, 它们必须以相反的顺序释放, 并且所有锁的释放必须在它们被获取的同一个词法范围内。

尽管synchronized方法和语句的作用域机制使得monitor锁的编程变得更简单, 并且有助于避免许多调用锁的常见编程错误。但是很多场合, 需要以更灵活的方式使用锁。例如, 一些算法在遍历并发访问的数据结构时, 需要用到"hand-over-hand"(手递手)或"chain locking"(链式锁)的方式: 先获取节点A的锁, 其次节点B, 然后释放A并获取C, 接下来释放B并获取D, 以此类推。Lock接口的实现允许在不同的域中获取和释放锁、允许以一定的顺序获取和释放多个锁等技术, 使这样技术的成为可能。

伴随着灵活性的增加, 同时也带来了额外的责任。块状结构锁的缺失, 移除了synchronized方法和语句中的锁的自动释放功能。大多数情况下, 使用如下习语:
    Lock l = ...;
    l.lock();
    try {
        // access the resource protected by this lock
    } finally {
        l.unlock();
    }

当加锁和解锁出现在不同作用域时, 必须注意, 所有执行代码持有锁时确保被try-finally或try-catch保护, 保证必要时释放锁。

通过提供获取锁的非阻塞尝试(tryLock())、获取锁的可中断尝试(lockInterruptibly())、获取锁的可超时尝试(tryLock(long, TimeUnit)), Lock实现在synchronized方法和语句的使用上提供了额外功能。

Lock类还可以提供和隐式monitor锁完全不一样的行为和语义, 例如确保顺序、不可重入使用、或死锁检测。如果实现提供了这样专门的语义, 那么必须记录下来。

注意, Lock实例只是普通的对象, 并且它们本身可以用于synchronized语句中的目标。获取Lock实例的monitor锁, 和调用那个实例的任何lock方法没有指定的关系。为了避免混淆, 建议不要以这种方式使用Lock实例, 除非在它们自己的实现中。
    Lock lock = ...;
    synchronized(lock) {
        // do some thing
    }
除非特别注明, 否则为任意参数传递空值, 都将导致抛出空指针异常。

************************************************************
内存同步

所有锁实现必须保证与内置的monitor锁, 提供相同的内存同步语义, 如Java语言规范(17.4 内存模型)中所述:
    1、成功的lock操作和成功的Lock行为, 拥有一样的内存同步效果
    2、成功的unlock操作和成功的Unlock行为, 拥有一样的内存同步效果。

失败的locking和unlocking操作, 和可重入的locking/unlocking操作, 不需要任何内存同步效果。

************************************************************
实现的注意事项
获取锁的三种形式(可中断、不可中断和定时), 在性能特征、顺序保证或其他实现质量上可能有所不同。此外, 在给定的Lock类中, 中断正在进行的锁获取的能力可能是不可用的。因此, 实现不必为了获取锁的三种形式, 定义完全相同的保证和语义, 也不必支持正在进行的锁获取的中断。实现需要清晰地记录下各个锁方法提供的语义和保证, 还必须遵从接口中定义的中断语义, 在一定程度上支持锁获取的中断: 要么完全支持, 要么只支持方法入口。

由于中断通常意味着取消, 而且对中断的请求通常是不频繁的, 因此实现可以优先响应中断而不是正常的方法返回。这是真的，即使它可以表明, 中断发生在另一个操作可能已解除阻塞的线程之后。实现应该记录下这种行为。


######################################## Method ############################################
----------------------------------------- void lock();
获取锁:
    如果锁不可用, 那么为了线程调度的目的, 当前线程会被禁用且处于休眠状态, 直到获取到锁。
实现的注意事项:
    1、 Lock实现可能可以发现锁的错误使用, 例如调用导致的死锁, 并且在某些情况下可能会抛出一个(未检测)的错误。这样的情况和异常类型必须记录在这个Lock实现中。


----------------------------------------- void lockInterruptibly() throws InterruptedException;
获取锁, 除非当前线程被中断(调用Thread的interrupt方法)

如果锁可用, 获取锁并立刻返回;
如果锁不可用, 那么为了线程调度的目的, 当前线程不可用, 并且处于休眠状态直到两个事情发生:
    1、当前线程获取到锁。
    2、其它线程中断了当前线程, 并且支持锁获取的中断。

如果当前线程:
    1、进入这个方法时, 已经设置了它的中断状态
    2、当获取锁时被中断, 且当前线程支持锁获取的中断
那么将抛出中断异常(InterruptedException), 且会清除当前线程的中断状态

实现注意事项:
    1、在某些实现中, 中断锁获取的能力是不可能的, 而且即使可以, 也可能是昂贵的操作。开发人员应该意识到可能有这种情况出现。当这种情况出现时, 实现应该记录下来。
    2、实现可能更倾向于响应中断, 而不是正常的方法返回。
    3、Lock实现可能可以发现锁的错误使用, 例如调用引起的死锁, 并且在某些情况下可能会抛出未检查的异常。这种情况和异常必须记录在Lock的实现中。


----------------------------------------- boolean tryLock();
当且仅当锁在调用时是空闲的, 获取到锁

如果锁是可用的, 获取到锁并立刻返回结果值(true)
如果锁是不可用的, 那么这个方法会立刻返回结果值(false)

这个方法的一个典型的使用习语:
Lock lock = ...;
if (lock.tryLock()) {
    try {
        // manipulate protected state
    } finally {
        lock.unlock();
    }
} else {
    // perform alternative actions
}

这样的使用方式, 若是获取到了锁, 确保了锁会被解锁; 且若是没有获取到锁, 不会尝试解锁


----------------------------------------- boolean tryLock(long time, TimeUnit unit) throws InterruptedException;

在给定的时间内, 如果锁是空闲的, 则获取到锁。并且, 当前线程不会被中断(Thread.interrupt)。

如果锁是可用的, 这个方法会立刻返回结果值(true)。
如果锁是不可用的, 那么为了线程调度的目的, 当前线程被禁用, 并且处于休眠状态直到三件事情发生:
    1、当前线程获取到锁
    2、其他线程中断了当前线程, 并且支持锁获取的中断
    3、指定的等待时间流逝
如果获取到锁, 那么会返回结果值(true)。

如果当前线程:
    1、进入这个方法时, 已经设置了它的中断状态
    2、当获取锁时被中断, 且当前线程支持锁获取的中断
那么会抛出中断异常(InterruptedException), 并且会清除当前线程的中断状态

如果耗光了了指定的等待时间, 那么会返回结果值(false)。
如果时间小于或等于0, 那么方法完全不会等待。

实现注意事项:
    1、中断锁请求在某些实现中, 可能是不可以的, 并且即使可以, 也会是一种昂贵的操作。开发人员应该意识到可能有这种情况出现。当这种情况出现时, 实现应该记录下来。
    2、实现更倾向于相应中断, 而不是正常的方法返回, 或者报告超时
    3、Lock实现可能可以发现锁的错误使用, 像调用引起的死锁, 并且在某些情况下会抛出一个(未被检测的)异常。这样的情况和异常类型必须记录在Lock实现上。


----------------------------------------- void unlock();
释放锁

实现注意事项:
    1、Lock实现通常会限制哪个线程可以释放锁(通常情况下, 只有锁的持有者可以释放锁), 如果违反了限制, 将会抛出一个未检查的异常。任何约束和异常类型, 都必须记录在Lock实现内。


----------------------------------------- Condition newCondition();
返回绑定这个Lock实例的一个新的Condition实例

等待这个condition之前, 当前线程必须持有锁。调用Condition的await()方法, 将会在等待之前自动释放锁, 并且在等待返回之前重新获取锁。

实现注意事项:
    1、Condition实例的具体操作, 依赖于Lock实现, 并且必须记录在哪个实现上。
