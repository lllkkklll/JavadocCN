---------------------------- Object类的方法
1、 wait()
导致当前线程等待, 直到另一个线程调用此对象的notify()或notifyAll()方法。换句话说, 这个方法的实际表现, 就像简单执行调用wait(0)。
当前线程必须拥有此对象的锁。此线程释放这个锁的拥有权, 并等到其他线程通过调用notify或notifyAll方法, 通知等待此对象锁的线程醒来。然后, 线程等到它重新获取到锁的拥有权并恢复执行。

因为在一个参数的版本中, 中断和虚假唤醒是有可能的, 所以这个方法应该总是在循环中使用: 
    synchronized (obj) {
        while (<condition does not hold>)
            obj.wait();
        ... // Perform action appropriate to condition
    }

这个方法应该只能被拥有这个对象锁的线程调用。查看notify方法, 获取线程成为锁拥有者的描述信息。

2、 wait(long timeout)
导致当前线程等待, 直到另一个线程调用这个对象的notify()或者notifyAll()方法, 或者过去了指定的时间。
当前线程必须拥有此对象的锁。
这个方法会导致当前线程(称之为T)将自身放入此对象的等待集中, 并且交出当前对象任何、所有的同步权。线程T由于线程调度的原因而被禁用, 并且休眠, 直到以下四种情况发生: 
    1. 其他线程调用的此对象的notify方法。
    2. 其他线程调用的此对象的notifyAll方法。
    3. 其他线程终端了线程T。
    4. 超过指定的实时时间, 或多或少。如果超时时间是0, 无论如何, 实时时间都不会被考虑且线程只会等待直到被通知。
然后, 从此对象的等待集中删除线程T, 并重新启用线程调度。然后它会其他线程以常规方式竞争同步对象的权利; 一旦它获取到对象的控制权, 它对该对象的所有同步声明将恢复到之前的状态 - 即, 等待方法被调用时的状态。接下来, 线程T从wait方法的调用中返回。因此, 从等待方法中返回时, 对象和线程T的同步状态就和wait方法被调用时一样。

一个线程也可以不被通知、中断和超时而唤醒, 所谓的虚假唤醒。尽管这很少在实践中发生, 但是应用必须通过测试导致线程被唤醒的条件, 防止这种情况, 并在条件不满足时继续等待。
换句话说, 等待应该总是出现在循环中, 就像这样: 
synchronized (obj) {
    while (<condition does not hold>)
        obj.wait(timeout);
    ... // Perform action appropriate to condition
}

(获取这个主题的更多信息, 查看Doug Lea的"Java并发编程(第二版)"(Addison-Wesley, 2000)的3.2.3节, 或者Joshua Bloch的"Java高效编程指南"(Addison-Wesley, 2001)的第50项)。

如果当前线程之前或者正在等待时, 其他线程中断它会抛出InterruptedException。直到这个对象锁状态恢复成上面描述的那样, 这个异常才不会被抛出。
注意: wait方法, 它将当前线程放入此对象的等待集中, 解锁只针对此对象;当线程等待时, 当前线程同步的其他对象依然维持锁的状态。
这个方法只能被拥有此对象锁的一个线程调用。查看notify方法了解线程如何获取锁。

3、 notify()
唤醒一个正在等待此对象锁的独立线程。如果任何线程正在等待这个对象, 那么他们中的一个将被唤醒。决定是任意的, 由实现自由裁定。线程通过调用wait方法中的一个, 来等待对象锁。
在当前线程放弃这个对象锁之前, 被唤醒的线程无法继续运行。被唤醒的线程将会和其他可能竞争同步这个对象的线程, 以常规方式竞争。例如, 被唤醒的线程没有成为下一个锁定这个对象线程的可靠特权和劣势(即: 唤醒线程下一次竞争时没有特权和劣势, 和其他线程一样)。
这个方法只能被拥有这个对象锁的线程所调用。线程成为对象锁的所有者有三种方式:
    1. 执行那个对象的同步实例方法。
    2. 执行对象同步的synchronized表达体。
    3. 对于Class类的对象, 执行那个类的synchronized静态方法。
一个线程同一时刻只能拥有一个对象锁。

4、 notifyAll()
唤醒所有正在此对象锁的线程。线程通过调用其中一个wait方法, 来等待对象锁。
醒来的线程不能开始运行, 直到当前线程放弃此对象的锁。醒来的线程将会以常规模式和其他在此对象上活跃竞争同步的线程竞争; 例如: 醒来的线程不会享有成为下一个锁住此对象的线程的特权和劣势。
这个方法应该只能被拥有此对象锁的线程调用。查看notify方法获取线程成为锁拥有者方法的描述信息。
