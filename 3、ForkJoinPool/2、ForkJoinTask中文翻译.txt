---------------------------- ForkJoinTask类Javadoc文档翻译

任务的抽象基础类, 在ForkJoinPool中运行。ForkJoinTask是一个类似线程的实体, 它比常规线程更轻量级。大量的任务和子任务可能被ForkJoinPool中少量的实际线程所招待, 以一些使用限制为代价。

当"主"ForkJoinTask被显示地提交到ForkJoinPool, 它就开始执行, 或者, 如果还没有参与ForkJoin计算的话, 就使用fork、invoke或相关方法在ForkJoinPool.commonPool()中开始。一旦开始, 它通常会转而启动其他子任务。正如这个类名所声明的那样, 许多使用ForkJoinTask的程序只使用fork和join方法, 或类似于invokeAll的派生方法。但是, 这个类还提供了许多其他方法, 这些方法可以在高级的用法中发挥作用, 以及允许支持新fork/join处理形式的扩展机制。

ForkJoinTask是Future的一个轻量级形式。ForkJoinTask的效率源于一组限制(仅部分静态实施), 这些限制反映了它们的主要用途: 计算纯函数或操作纯孤立对象的计算任务。主要的协调机制是fork(安排异步执行)和join(不会开始执行, 直到任务结果已经被计算出来)。理想情况下, 计算应该规避同步方法或同步块, 而且应该尽量减少其他阻塞同步, 除非join其他任务或者使用类似Phaser的同步器(配合fork/join调度)。可细分的任务也不应该执行阻塞I/O, 并且理想情况下应该可以访问那些完全独立于其他运行任务可访问的变量。通过抛出无权检查的异常(如IOExceptions), 这些指导原则得到了松散的执行。但是, 计算仍然可能遇到未检查的异常, 这些异常被重新抛出尝试join它们的调用者。这些异常还可能包括源自内部资源耗尽的RejectedExecutionException, 例如分配内部的任务队列失败。重新抛出的异常与常规异常的行为方式相同, 但在有些情况下, 包含启动计算的线程和实际遇到的异常线程堆栈跟踪(正如使用ex.printStackTrace()所显示的那样); 最低限度只有后者。

可以定义和使用可能阻塞的ForkJoinTasks, 但是这样做需要三个更进一步的注意事项: (1) 几乎没有其他任务的完成, 应该依赖于外部同步或I/O阻塞的任务。事件风格的异步任务从不被join(例如, CountedCompleter的子类化), 通常属于这一类。 (2) 为了最小化资源影响, 任务应该是很小的; 理想的情况下, 只执行(可能)堵塞的动作。 (3) 除非使用ForkJoinPool.ManagedBlocker的API, 或者已知可能堵塞的任务数量, 小于池的ForkJoinPool.getParallelism级别; 否则池无法保证有足够的线程可用, 用来确保进度和良好表现。

等待计算和提取任务结果的主要方法是join, 但有几个变体: Future.get方法支持计算可中断 和/或 超时等待, 并且使用Future惯例报告结果。invoke方法语义上等于fork();join(), 但总是尝试在当前线程中开始执行。这些方法的"quiet"形式不会提取结果或报告异常。当正在执行一组任务, 需要推迟处理结果或异常直到全部完成, 这些可能是有用的。invokeAll方法(大多数版本中是可用的)执行并行调用的最常规形式: fork一组任务并且join它们所有。

在最典型的用法中, fork-join对类似并行递归函数中的调用(fork)和返回(join)执行。与其他形式的递归调用一样, 返回(join)应该在最内层执行。例如, a.fork(); b.fork(); b.join(); a.join(); 可能比在b之前join a更高效。

任务的执行状态可能在几个细节级别中查询: 如果任务以任何方式完成, 那么isDone为真(包括任务被取消没有执行的例子); 如果任务没有取消或遇到异常的完成, 那么isCompletedNormally为真; 如果任务被取消, 那么isCancelled为真(在这种情况下, getException返回CancellationException); 如果任务不是被取消就是遇到异常, 那么isCompletedAbnormally为真, 在这种情况下, getException要么返回遇到的异常, 要么返回CancellationException。

ForkJoinTask类通常不会被直接子类化。相反, 会子类化支持fork/join的一种特殊处理风格的抽象类, 经典案例:   RecursiveAction用于大多数不返回结果的计算, RecursiveTask用于返回结果, 并且CountedCompleter用于那些已完成的动作触发其他动作。正常情况下, 具体的ForkJoinTask子类声明包含其参数的字段(在构造函数中建立), 然后定义一个计算方法, 该方法以某种方式使用这个基础类提供的控制方法。

当且仅当完成依赖是不循环的, join方法和其变体才合适使用; 也就是说, 并行计算可以描述为一个有向无环图(DAG)。否则, 当任务循环等待彼此, 执行可能会遇到死锁形式。但是, 这个框架支持其他方法和技术(如: 使用Phaser, helpQuiesce和complete), 这些方法和技术可能用于为那些非静态结构的难题如DAG, 用来构建自定义子类。为了支持这样的用法, ForkJoinTask使用setForkJoinTaskTag或compareAndSetForkJoinTaskTag自动标记一个short值, 并且使用getForkJoinTaskTag进行检查。ForkJoinTask实现不会出于任何目的得使用这些受保护的方法或标记, 但是它们可以用来构造专门的子类。例如: 并行图遍历可以使用提供的方法, 来避免重复访问已经处理过的节点/任务。(用于标记的方法名字是笨重的, 部分原因是为了鼓励方法定义, 可以反映它们的用法模式。)

大多数支持的基础方法是final的, 以防止覆盖与底层轻量级任务调度框架内在关联的实现。创建新的、基础的、fork/join处理风格的开发人员, 应该最低限度得实现受保护的方法: exec、setRawResult和getRawResult, 同时引入一个可以在子类中实现的抽象计算方法, 可能依赖于这个类提供的其他受保护的方法。

ForkJoinTask应该执行相对少量的计算。大任务应该被分为更小的子任务, 通常使用递归分解。这是一条非常粗略的经验法则, 一个任务应该执行大于100而小于1000的基本计算步骤, 并且应该避免无限循环。如果任务过大, 那么并行就不能提高吞吐量。如果过小, 那么内存和内部任务维护开销可能会超过处理开销。

这个类为Runnable和Callable提供了合适的方法, 当ForkJoinTasks与其他类型的任务混合执行时, 这些方法可能有用。当所有任务都是这种形式时, 请考虑使用异步模式构造的池。

ForkJoinTasks是可序列化的, 这使得他们可以在扩展中使用(如: 远程执行框架)。合理的做法是只在之前或之后序列化任务, 而不是在执行期间序列化任务。执行过程中不依赖于序列化。
